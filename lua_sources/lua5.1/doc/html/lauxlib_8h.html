<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>lua: lauxlib.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body onload='searchBox.OnSelectItem(0);'>
<!-- Generated by Doxygen 1.7.2 -->
<script type="text/javascript"><!--
var searchBox = new SearchBox("searchBox", "search",false,'Search');
--></script>
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li id="searchli">
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Defines</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<h1>lauxlib.h File Reference</h1>  </div>
</div>
<div class="contents">
<code>#include &lt;stddef.h&gt;</code><br/>
<code>#include &lt;stdio.h&gt;</code><br/>
<code>#include &quot;<a class="el" href="lua_8h_source.html">lua.h</a>&quot;</code><br/>

<p><a href="lauxlib_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlua_l___reg.html">luaL_Reg</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlua_l___buffer.html">luaL_Buffer</a></td></tr>
<tr><td colspan="2"><h2><a name="define-members"></a>
Defines</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lauxlib_8h.html#a0ef5c05520dabbaa65ecbade53e719fa">luaL_getn</a>(L, i)&#160;&#160;&#160;((int)lua_objlen(L, i))</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lauxlib_8h.html#a6528439647f8e5928dd9151be7c89302">luaL_setn</a>(L, i, j)&#160;&#160;&#160;((void)0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lauxlib_8h.html#aba5d150de784924e9111ccf650bea087">luaI_openlib</a>&#160;&#160;&#160;luaL_openlib</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lauxlib_8h.html#ab8d4418d33cd59728435db95ac2caf5a">LUA_ERRFILE</a>&#160;&#160;&#160;(LUA_ERRERR+1)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lauxlib_8h.html#afe2e3018d561c14f2622fb32f425c111">luaL_argcheck</a>(L, cond, numarg, extramsg)&#160;&#160;&#160;((void)((cond) || luaL_argerror(L, (numarg), (extramsg))))</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lauxlib_8h.html#ad9917d22c79651fdd73d42c146b5056f">luaL_checkstring</a>(L, n)&#160;&#160;&#160;(luaL_checklstring(L, (n), NULL))</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lauxlib_8h.html#a732bc5882c4a5da46b236649ab6db47b">luaL_optstring</a>(L, n, d)&#160;&#160;&#160;(luaL_optlstring(L, (n), (d), NULL))</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lauxlib_8h.html#adb277a5f654228b51b66f95bcf883601">luaL_checkint</a>(L, n)&#160;&#160;&#160;((int)luaL_checkinteger(L, (n)))</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lauxlib_8h.html#ab4d7f693e9405558c725783a756e0aca">luaL_optint</a>(L, n, d)&#160;&#160;&#160;((int)luaL_optinteger(L, (n), (d)))</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lauxlib_8h.html#a0df2697cbe2d4a33e012ab336af44b9b">luaL_checklong</a>(L, n)&#160;&#160;&#160;((long)luaL_checkinteger(L, (n)))</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lauxlib_8h.html#a58ea6d94dccfa493103d8e112dd276b6">luaL_optlong</a>(L, n, d)&#160;&#160;&#160;((long)luaL_optinteger(L, (n), (d)))</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lauxlib_8h.html#a2bee94954917c5bccb05d6578f3c675b">luaL_typename</a>(L, i)&#160;&#160;&#160;lua_typename(L, lua_type(L,(i)))</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lauxlib_8h.html#aa49a7a47a683d6e7868ede50ceb826be">luaL_dofile</a>(L, fn)&#160;&#160;&#160;(luaL_loadfile(L, fn) || lua_pcall(L, 0, LUA_MULTRET, 0))</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lauxlib_8h.html#a1a0639bfde6b1e2f6181af45b0137cf5">luaL_dostring</a>(L, s)&#160;&#160;&#160;(luaL_loadstring(L, s) || lua_pcall(L, 0, LUA_MULTRET, 0))</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lauxlib_8h.html#a201407aa41ff74577c67308372a130d9">luaL_getmetatable</a>(L, n)&#160;&#160;&#160;(lua_getfield(L, LUA_REGISTRYINDEX, (n)))</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lauxlib_8h.html#aca033280b0176012ef290131876f706e">luaL_opt</a>(L, f, n, d)&#160;&#160;&#160;(lua_isnoneornil(L,(n)) ? (d) : f(L,(n)))</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lauxlib_8h.html#a63935c5b4cf5d45930c875f6cc5e1432">luaL_addchar</a>(B, c)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lauxlib_8h.html#abbe5398fb8c79198354ba483e334cfdf">luaL_putchar</a>(B, c)&#160;&#160;&#160;luaL_addchar(B,c)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lauxlib_8h.html#a2c5063f5c005f0ecd3fd69a9f7509073">luaL_addsize</a>(B, n)&#160;&#160;&#160;((B)-&gt;p += (n))</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lauxlib_8h.html#a3bfb758f2ac7c9ecb758e1aeaaa82d3d">LUA_NOREF</a>&#160;&#160;&#160;(-2)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lauxlib_8h.html#a004a6b76c047f3b94890a08dbdcbbee7">LUA_REFNIL</a>&#160;&#160;&#160;(-1)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lauxlib_8h.html#ad33a233129d81d873e9b5a65fc7d0c3a">lua_ref</a>(L, lock)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lauxlib_8h.html#ac9b78e96e9af92b1f43fa2fa016b263c">lua_unref</a>(L, ref)&#160;&#160;&#160;luaL_unref(L, LUA_REGISTRYINDEX, (ref))</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lauxlib_8h.html#a7bce9002427e63aa572e53f77432a7ee">lua_getref</a>(L, ref)&#160;&#160;&#160;lua_rawgeti(L, LUA_REGISTRYINDEX, (ref))</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lauxlib_8h.html#a2015fce24247ce967682fd7458684af2">luaL_reg</a>&#160;&#160;&#160;<a class="el" href="structlua_l___reg.html">luaL_Reg</a></td></tr>
<tr><td colspan="2"><h2><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="structlua_l___reg.html">luaL_Reg</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lauxlib_8h.html#a48bebf7b56d108021c1ae29549c912f9">luaL_Reg</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="structlua_l___buffer.html">luaL_Buffer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lauxlib_8h.html#a5f2195b3845806aa4bd9117b11b4d91c">luaL_Buffer</a></td></tr>
<tr><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">LUALIB_API void()&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lauxlib_8h.html#ae352d571a7b93c6b311b7aa993f9aaba">luaI_openlib</a> (<a class="el" href="lua_8h.html#a28186297f2e9f2de0652504633de8fb3">lua_State</a> *L, const char *libname, const <a class="el" href="structlua_l___reg.html">luaL_Reg</a> *l, int nup)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">LUALIB_API void()&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lauxlib_8h.html#a258c0fd40d57aec9cf62ebd74be7666e">luaL_register</a> (<a class="el" href="lua_8h.html#a28186297f2e9f2de0652504633de8fb3">lua_State</a> *L, const char *libname, const <a class="el" href="structlua_l___reg.html">luaL_Reg</a> *l)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">LUALIB_API int()&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lauxlib_8h.html#aed3f129411ba1ec14f813d650f16384d">luaL_getmetafield</a> (<a class="el" href="lua_8h.html#a28186297f2e9f2de0652504633de8fb3">lua_State</a> *L, int obj, const char *e)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">LUALIB_API int()&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lauxlib_8h.html#af26aec8cce4a3f4448c60f402d78f17d">luaL_callmeta</a> (<a class="el" href="lua_8h.html#a28186297f2e9f2de0652504633de8fb3">lua_State</a> *L, int obj, const char *e)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">LUALIB_API int()&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lauxlib_8h.html#a022056a7197e2e2c12f2b65b2993fd53">luaL_typerror</a> (<a class="el" href="lua_8h.html#a28186297f2e9f2de0652504633de8fb3">lua_State</a> *L, int narg, const char *tname)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">LUALIB_API int()&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lauxlib_8h.html#a526c220d17273c63ce9973bcde4a2c4a">luaL_argerror</a> (<a class="el" href="lua_8h.html#a28186297f2e9f2de0652504633de8fb3">lua_State</a> *L, int numarg, const char *extramsg)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">LUALIB_API const char *()&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lauxlib_8h.html#af4af154dcb41f8990a572e6a00c349fc">luaL_checklstring</a> (<a class="el" href="lua_8h.html#a28186297f2e9f2de0652504633de8fb3">lua_State</a> *L, int numArg, size_t *l)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">LUALIB_API const char *()&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lauxlib_8h.html#a15b8c426b2e1b0cd1f9ddc32bc94df2f">luaL_optlstring</a> (<a class="el" href="lua_8h.html#a28186297f2e9f2de0652504633de8fb3">lua_State</a> *L, int numArg, const char *def, size_t *l)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">LUALIB_API <a class="el" href="lua_8h.html#af0a6ed3b852d680769cfc410a0672172">lua_Number</a>()&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lauxlib_8h.html#a3e39a4d35c3ce1555126e372a8a329c3">luaL_checknumber</a> (<a class="el" href="lua_8h.html#a28186297f2e9f2de0652504633de8fb3">lua_State</a> *L, int numArg)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">LUALIB_API <a class="el" href="lua_8h.html#af0a6ed3b852d680769cfc410a0672172">lua_Number</a>()&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lauxlib_8h.html#a001e2679c64c24eefbaf478fd0c22f97">luaL_optnumber</a> (<a class="el" href="lua_8h.html#a28186297f2e9f2de0652504633de8fb3">lua_State</a> *L, int nArg, <a class="el" href="lua_8h.html#af0a6ed3b852d680769cfc410a0672172">lua_Number</a> def)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">LUALIB_API <a class="el" href="lua_8h.html#a362144baa0cfb14dc38fd21438053d73">lua_Integer</a>()&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lauxlib_8h.html#ab9c2bb4294fb7a81d3745dad5711cd63">luaL_checkinteger</a> (<a class="el" href="lua_8h.html#a28186297f2e9f2de0652504633de8fb3">lua_State</a> *L, int numArg)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">LUALIB_API <a class="el" href="lua_8h.html#a362144baa0cfb14dc38fd21438053d73">lua_Integer</a>()&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lauxlib_8h.html#a2b17cdda9e7ed73a1cd152cd386dc7a4">luaL_optinteger</a> (<a class="el" href="lua_8h.html#a28186297f2e9f2de0652504633de8fb3">lua_State</a> *L, int nArg, <a class="el" href="lua_8h.html#a362144baa0cfb14dc38fd21438053d73">lua_Integer</a> def)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">LUALIB_API void()&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lauxlib_8h.html#a724f5a5aeee97c0b40948c8bca91341c">luaL_checkstack</a> (<a class="el" href="lua_8h.html#a28186297f2e9f2de0652504633de8fb3">lua_State</a> *L, int sz, const char *msg)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">LUALIB_API void()&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lauxlib_8h.html#ae5f465fb757069d016a10b106c69bdd7">luaL_checktype</a> (<a class="el" href="lua_8h.html#a28186297f2e9f2de0652504633de8fb3">lua_State</a> *L, int narg, int t)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">LUALIB_API void()&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lauxlib_8h.html#ad78c85dce421e9cb793e205b9e81c640">luaL_checkany</a> (<a class="el" href="lua_8h.html#a28186297f2e9f2de0652504633de8fb3">lua_State</a> *L, int narg)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">LUALIB_API int()&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lauxlib_8h.html#a0e9e032108e7aedc05836b0c1d72a0fa">luaL_newmetatable</a> (<a class="el" href="lua_8h.html#a28186297f2e9f2de0652504633de8fb3">lua_State</a> *L, const char *tname)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">LUALIB_API void *()&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lauxlib_8h.html#aed8d8e4f3b95c6bcac246ec9895027b1">luaL_checkudata</a> (<a class="el" href="lua_8h.html#a28186297f2e9f2de0652504633de8fb3">lua_State</a> *L, int ud, const char *tname)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">LUALIB_API void()&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lauxlib_8h.html#a269122a77674ca63c9193c2a30b4729e">luaL_where</a> (<a class="el" href="lua_8h.html#a28186297f2e9f2de0652504633de8fb3">lua_State</a> *L, int lvl)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">LUALIB_API int()&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lauxlib_8h.html#a994f73d7985c30672469a260d9e86ae6">luaL_error</a> (<a class="el" href="lua_8h.html#a28186297f2e9f2de0652504633de8fb3">lua_State</a> *L, const char *fmt,...)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">LUALIB_API int()&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lauxlib_8h.html#a638633914d3a19650db8320c1fccf161">luaL_checkoption</a> (<a class="el" href="lua_8h.html#a28186297f2e9f2de0652504633de8fb3">lua_State</a> *L, int narg, const char *def, const char *const lst[])</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">LUALIB_API int()&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lauxlib_8h.html#a2b69e67252d95df410818251f4b2d8e5">luaL_ref</a> (<a class="el" href="lua_8h.html#a28186297f2e9f2de0652504633de8fb3">lua_State</a> *L, int t)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">LUALIB_API void()&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lauxlib_8h.html#a6200030ecae784852045161274501e0e">luaL_unref</a> (<a class="el" href="lua_8h.html#a28186297f2e9f2de0652504633de8fb3">lua_State</a> *L, int t, int ref)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">LUALIB_API int()&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lauxlib_8h.html#afa862c5bdbbcfc8f46e0cac9f32a771e">luaL_loadfile</a> (<a class="el" href="lua_8h.html#a28186297f2e9f2de0652504633de8fb3">lua_State</a> *L, const char *filename)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">LUALIB_API int()&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lauxlib_8h.html#a74d560ea0256e7b48496a4acb1d7522e">luaL_loadbuffer</a> (<a class="el" href="lua_8h.html#a28186297f2e9f2de0652504633de8fb3">lua_State</a> *L, const char *buff, size_t sz, const char *name)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">LUALIB_API int()&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lauxlib_8h.html#ac88130d6214ff6b3e2f1781f327807eb">luaL_loadstring</a> (<a class="el" href="lua_8h.html#a28186297f2e9f2de0652504633de8fb3">lua_State</a> *L, const char *s)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">LUALIB_API <a class="el" href="lua_8h.html#a28186297f2e9f2de0652504633de8fb3">lua_State</a> *()&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lauxlib_8h.html#a7d8712fcede90ae93d5a9a7b409c586e">luaL_newstate</a> (void)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">LUALIB_API const char *()&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lauxlib_8h.html#a46672be75da57e1a464c5c6d80f19064">luaL_gsub</a> (<a class="el" href="lua_8h.html#a28186297f2e9f2de0652504633de8fb3">lua_State</a> *L, const char *s, const char *p, const char *r)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">LUALIB_API const char *()&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lauxlib_8h.html#a561116e7d323baa7ae514054bc15978f">luaL_findtable</a> (<a class="el" href="lua_8h.html#a28186297f2e9f2de0652504633de8fb3">lua_State</a> *L, int idx, const char *fname, int szhint)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">LUALIB_API void()&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lauxlib_8h.html#aab6af54c782855fee2bef84eb41bdc00">luaL_buffinit</a> (<a class="el" href="lua_8h.html#a28186297f2e9f2de0652504633de8fb3">lua_State</a> *L, <a class="el" href="structlua_l___buffer.html">luaL_Buffer</a> *B)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">LUALIB_API char *()&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lauxlib_8h.html#adb0d0b797f1b8cc8ec4cda17a2939f87">luaL_prepbuffer</a> (<a class="el" href="structlua_l___buffer.html">luaL_Buffer</a> *B)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">LUALIB_API void()&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lauxlib_8h.html#a06fceedb3abb1272566ca22c96e34b95">luaL_addlstring</a> (<a class="el" href="structlua_l___buffer.html">luaL_Buffer</a> *B, const char *s, size_t l)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">LUALIB_API void()&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lauxlib_8h.html#ad9c038f6e108e216011aca1801f84f44">luaL_addstring</a> (<a class="el" href="structlua_l___buffer.html">luaL_Buffer</a> *B, const char *s)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">LUALIB_API void()&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lauxlib_8h.html#aeeb03d69681da0ec0e952b582ce3841c">luaL_addvalue</a> (<a class="el" href="structlua_l___buffer.html">luaL_Buffer</a> *B)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">LUALIB_API void()&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lauxlib_8h.html#aac5dfab9ba0ced4f5ae3b22aa35faffe">luaL_pushresult</a> (<a class="el" href="structlua_l___buffer.html">luaL_Buffer</a> *B)</td></tr>
</table>
<hr/><h2>Define Documentation</h2>
<a class="anchor" id="ab8d4418d33cd59728435db95ac2caf5a"></a><!-- doxytag: member="lauxlib.h::LUA_ERRFILE" ref="ab8d4418d33cd59728435db95ac2caf5a" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LUA_ERRFILE&#160;&#160;&#160;(LUA_ERRERR+1)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a7bce9002427e63aa572e53f77432a7ee"></a><!-- doxytag: member="lauxlib.h::lua_getref" ref="a7bce9002427e63aa572e53f77432a7ee" args="(L, ref)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define lua_getref</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">L, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">ref&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;lua_rawgeti(L, LUA_REGISTRYINDEX, (ref))</td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a3bfb758f2ac7c9ecb758e1aeaaa82d3d"></a><!-- doxytag: member="lauxlib.h::LUA_NOREF" ref="a3bfb758f2ac7c9ecb758e1aeaaa82d3d" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LUA_NOREF&#160;&#160;&#160;(-2)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ad33a233129d81d873e9b5a65fc7d0c3a"></a><!-- doxytag: member="lauxlib.h::lua_ref" ref="ad33a233129d81d873e9b5a65fc7d0c3a" args="(L, lock)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define lua_ref</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">L, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">lock&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<b>Value:</b><div class="fragment"><pre class="fragment">((lock) ? <a class="code" href="lauxlib_8h.html#a2b69e67252d95df410818251f4b2d8e5">luaL_ref</a>(L, <a class="code" href="lua_8h.html#a3524c2bbc8fcf847dc083246b62945dd">LUA_REGISTRYINDEX</a>) : \
      (<a class="code" href="lua_8h.html#af2db74e1d8e7062bf5d1a2a779e53369">lua_pushstring</a>(L, <span class="stringliteral">&quot;unlocked references are obsolete&quot;</span>), <a class="code" href="lua_8h.html#aae6c05ddea7bd110a3e84595ef92e601">lua_error</a>(L), 0))
</pre></div>
</div>
</div>
<a class="anchor" id="a004a6b76c047f3b94890a08dbdcbbee7"></a><!-- doxytag: member="lauxlib.h::LUA_REFNIL" ref="a004a6b76c047f3b94890a08dbdcbbee7" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LUA_REFNIL&#160;&#160;&#160;(-1)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ac9b78e96e9af92b1f43fa2fa016b263c"></a><!-- doxytag: member="lauxlib.h::lua_unref" ref="ac9b78e96e9af92b1f43fa2fa016b263c" args="(L, ref)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define lua_unref</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">L, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">ref&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;luaL_unref(L, LUA_REGISTRYINDEX, (ref))</td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="aba5d150de784924e9111ccf650bea087"></a><!-- doxytag: member="lauxlib.h::luaI_openlib" ref="aba5d150de784924e9111ccf650bea087" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define luaI_openlib&#160;&#160;&#160;luaL_openlib</td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a63935c5b4cf5d45930c875f6cc5e1432"></a><!-- doxytag: member="lauxlib.h::luaL_addchar" ref="a63935c5b4cf5d45930c875f6cc5e1432" args="(B, c)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define luaL_addchar</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">B, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">c&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<b>Value:</b><div class="fragment"><pre class="fragment">((void)((B)-&gt;p &lt; ((B)-&gt;buffer+<a class="code" href="luaconf_8h.html#af360ad37a770dfdc29291a99c398f42d">LUAL_BUFFERSIZE</a>) || <a class="code" href="lauxlib_8h.html#adb0d0b797f1b8cc8ec4cda17a2939f87">luaL_prepbuffer</a>(B)), \
   (*(B)-&gt;p++ = (char)(c)))
</pre></div><p>luaL_addchar</p>
<p>[-0, +0, m]</p>
<p>void luaL_addchar (<a class="el" href="structlua_l___buffer.html">luaL_Buffer</a> *B, char c);</p>
<p>Adds the character c to the buffer B (see <a class="el" href="structlua_l___buffer.html">luaL_Buffer</a>).</p>
<p>把字符c加入缓冲区B（参考luaL_Buffer）。 </p>

</div>
</div>
<a class="anchor" id="a2c5063f5c005f0ecd3fd69a9f7509073"></a><!-- doxytag: member="lauxlib.h::luaL_addsize" ref="a2c5063f5c005f0ecd3fd69a9f7509073" args="(B, n)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define luaL_addsize</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">B, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">n&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;((B)-&gt;p += (n))</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>luaL_addsize</p>
<p>[-0, +0, m]</p>
<p>void luaL_addsize (<a class="el" href="structlua_l___buffer.html">luaL_Buffer</a> *B, size_t n);</p>
<p>Adds to the buffer B (see <a class="el" href="structlua_l___buffer.html">luaL_Buffer</a>) a string of length n previously copied to the buffer area (see luaL_prepbuffer).</p>
<p>把前一个复制到缓冲区（参考luaL_prepbuffer）的长度n的字符串加入缓冲B（参考luaL_Buffer） </p>

</div>
</div>
<a class="anchor" id="afe2e3018d561c14f2622fb32f425c111"></a><!-- doxytag: member="lauxlib.h::luaL_argcheck" ref="afe2e3018d561c14f2622fb32f425c111" args="(L, cond, numarg, extramsg)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define luaL_argcheck</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">L, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">cond, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">numarg, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">extramsg&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;((void)((cond) || luaL_argerror(L, (numarg), (extramsg))))</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>luaL_argcheck</p>
<p>[-0, +0, v]</p>
<p>void luaL_argcheck (lua_State *L, int cond, int narg, const char *extramsg);</p>
<p>Checks whether cond is true. If not, raises an error with the following message, where func is retrieved from the call stack:</p>
<p>bad argument #&lt;narg&gt; to &lt;func&gt; (&lt;extramsg&gt;)</p>
<p>检查条件是否为真。</p>
<p>如果不是，用下面的信息引发一个错误，其中func是从调用堆栈中重新取得。</p>
<p>bad argument #&lt;narg&gt; to &lt;func&gt; (&lt;extramsg&gt;) </p>

</div>
</div>
<a class="anchor" id="adb277a5f654228b51b66f95bcf883601"></a><!-- doxytag: member="lauxlib.h::luaL_checkint" ref="adb277a5f654228b51b66f95bcf883601" args="(L, n)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define luaL_checkint</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">L, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">n&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;((int)luaL_checkinteger(L, (n)))</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>luaL_checkint</p>
<p>[-0, +0, v]</p>
<p>int luaL_checkint (lua_State *L, int narg);</p>
<p>Checks whether the function argument narg is a number and returns this number cast to an int.</p>
<p>检查函数参数narg是否为一个数，并且把这个数转换为整数然后返回。 </p>

</div>
</div>
<a class="anchor" id="a0df2697cbe2d4a33e012ab336af44b9b"></a><!-- doxytag: member="lauxlib.h::luaL_checklong" ref="a0df2697cbe2d4a33e012ab336af44b9b" args="(L, n)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define luaL_checklong</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">L, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">n&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;((long)luaL_checkinteger(L, (n)))</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>luaL_checklong</p>
<p>[-0, +0, v]</p>
<p>long luaL_checklong (lua_State *L, int narg);</p>
<p>Checks whether the function argument narg is a number and returns this number cast to a long.</p>
<p>检查函数参数narg是否是一个数，并且把这个数转换为长整型然后返回。 </p>

</div>
</div>
<a class="anchor" id="ad9917d22c79651fdd73d42c146b5056f"></a><!-- doxytag: member="lauxlib.h::luaL_checkstring" ref="ad9917d22c79651fdd73d42c146b5056f" args="(L, n)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define luaL_checkstring</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">L, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">n&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;(luaL_checklstring(L, (n), NULL))</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>luaL_checkstring</p>
<p>[-0, +0, v]</p>
<p>const char *luaL_checkstring (lua_State *L, int narg);</p>
<p>Checks whether the function argument narg is a string and returns this string.</p>
<p>This function uses lua_tolstring to get its result, so all conversions and caveats of that function apply here.</p>
<p>检查函数参数narg是否字符串并返回它。</p>
<p>本函数用lua_tolstring取得其结果，所以那个函数的所有变换和警告也适用于此处。 </p>

</div>
</div>
<a class="anchor" id="aa49a7a47a683d6e7868ede50ceb826be"></a><!-- doxytag: member="lauxlib.h::luaL_dofile" ref="aa49a7a47a683d6e7868ede50ceb826be" args="(L, fn)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define luaL_dofile</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">L, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">fn&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;(luaL_loadfile(L, fn) || lua_pcall(L, 0, LUA_MULTRET, 0))</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>luaL_dofile</p>
<p>[-0, +?, m]</p>
<p>int luaL_dofile (lua_State *L, const char *filename);</p>
<p>Loads and runs the given file. It is defined as the following macro:</p>
<p>(luaL_loadfile(L, filename) || lua_pcall(L, 0, LUA_MULTRET, 0))</p>
<p>It returns 0 if there are no errors or 1 in case of errors.</p>
<p>加载并运行所给的文件，定义为如下宏</p>
<p>(luaL_loadfile(L, filename) || lua_pcall(L, 0, LUA_MULTRET, 0))</p>
<p>如果没有错误则返回0，如果出错返回1。 </p>

</div>
</div>
<a class="anchor" id="a1a0639bfde6b1e2f6181af45b0137cf5"></a><!-- doxytag: member="lauxlib.h::luaL_dostring" ref="a1a0639bfde6b1e2f6181af45b0137cf5" args="(L, s)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define luaL_dostring</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">L, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">s&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;(luaL_loadstring(L, s) || lua_pcall(L, 0, LUA_MULTRET, 0))</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>luaL_dostring</p>
<p>[-0, +?, m]</p>
<p>int luaL_dostring (lua_State *L, const char *str);</p>
<p>Loads and runs the given string. It is defined as the following macro:</p>
<p>(luaL_loadstring(L, str) || lua_pcall(L, 0, LUA_MULTRET, 0))</p>
<p>It returns 0 if there are no errors or 1 in case of errors.</p>
<p>加载并运行所给的字符串。定义为如下宏：</p>
<p>(luaL_loadstring(L, str) || lua_pcall(L, 0, LUA_MULTRET, 0))</p>
<p>如果没有错误则返回0，如果出错返回1。 </p>

</div>
</div>
<a class="anchor" id="a201407aa41ff74577c67308372a130d9"></a><!-- doxytag: member="lauxlib.h::luaL_getmetatable" ref="a201407aa41ff74577c67308372a130d9" args="(L, n)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define luaL_getmetatable</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">L, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">n&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;(lua_getfield(L, LUA_REGISTRYINDEX, (n)))</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>luaL_getmetatable</p>
<p>[-0, +1, -]</p>
<p>void luaL_getmetatable (lua_State *L, const char *tname);</p>
<p>Pushes onto the stack the metatable associated with name tname in the registry (see luaL_newmetatable).</p>
<p>把与注册表中的名字tname相关联的元表压栈。（见luaL_newmetatable）。 </p>

</div>
</div>
<a class="anchor" id="a0ef5c05520dabbaa65ecbade53e719fa"></a><!-- doxytag: member="lauxlib.h::luaL_getn" ref="a0ef5c05520dabbaa65ecbade53e719fa" args="(L, i)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define luaL_getn</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">L, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">i&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;((int)lua_objlen(L, i))</td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="aca033280b0176012ef290131876f706e"></a><!-- doxytag: member="lauxlib.h::luaL_opt" ref="aca033280b0176012ef290131876f706e" args="(L, f, n, d)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define luaL_opt</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">L, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">f, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">n, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">d&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;(lua_isnoneornil(L,(n)) ? (d) : f(L,(n)))</td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ab4d7f693e9405558c725783a756e0aca"></a><!-- doxytag: member="lauxlib.h::luaL_optint" ref="ab4d7f693e9405558c725783a756e0aca" args="(L, n, d)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define luaL_optint</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">L, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">n, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">d&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;((int)luaL_optinteger(L, (n), (d)))</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>luaL_optint</p>
<p>[-0, +0, v]</p>
<p>int luaL_optint (lua_State *L, int narg, int d);</p>
<p>If the function argument narg is a number, returns this number cast to an int. If this argument is absent or is nil, returns d. Otherwise, raises an error.</p>
<p>如果函数参数narg是数字，则把该数字转型为int返回。如果该参数不存在或为nil则返回d。否则引发错误。 </p>

</div>
</div>
<a class="anchor" id="a58ea6d94dccfa493103d8e112dd276b6"></a><!-- doxytag: member="lauxlib.h::luaL_optlong" ref="a58ea6d94dccfa493103d8e112dd276b6" args="(L, n, d)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define luaL_optlong</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">L, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">n, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">d&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;((long)luaL_optinteger(L, (n), (d)))</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>luaL_optlong</p>
<p>[-0, +0, v]</p>
<p>long luaL_optlong (lua_State *L, int narg, long d);</p>
<p>If the function argument narg is a number, returns this number cast to a long. If this argument is absent or is nil, returns d. Otherwise, raises an error.</p>
<p>如果函数参数narg是数字，则把该数字转型为long返回。如果该参数不存在或为nil则返回d。否则引发错误。 </p>

</div>
</div>
<a class="anchor" id="a732bc5882c4a5da46b236649ab6db47b"></a><!-- doxytag: member="lauxlib.h::luaL_optstring" ref="a732bc5882c4a5da46b236649ab6db47b" args="(L, n, d)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define luaL_optstring</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">L, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">n, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">d&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;(luaL_optlstring(L, (n), (d), NULL))</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>luaL_optstring</p>
<p>[-0, +0, v]</p>
<p>const char *luaL_optstring (lua_State *L, int narg, const char *d);</p>
<p>If the function argument narg is a string, returns this string. If this argument is absent or is nil, returns d. Otherwise, raises an error.</p>
<p>如果函数参数narg是字符串则返回它。如果该参数不存在或为nil则返回d。否则引发错误。 </p>

</div>
</div>
<a class="anchor" id="abbe5398fb8c79198354ba483e334cfdf"></a><!-- doxytag: member="lauxlib.h::luaL_putchar" ref="abbe5398fb8c79198354ba483e334cfdf" args="(B, c)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define luaL_putchar</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">B, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">c&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;luaL_addchar(B,c)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a2015fce24247ce967682fd7458684af2"></a><!-- doxytag: member="lauxlib.h::luaL_reg" ref="a2015fce24247ce967682fd7458684af2" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define luaL_reg&#160;&#160;&#160;<a class="el" href="structlua_l___reg.html">luaL_Reg</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a6528439647f8e5928dd9151be7c89302"></a><!-- doxytag: member="lauxlib.h::luaL_setn" ref="a6528439647f8e5928dd9151be7c89302" args="(L, i, j)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define luaL_setn</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">L, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">i, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">j&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;((void)0)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a2bee94954917c5bccb05d6578f3c675b"></a><!-- doxytag: member="lauxlib.h::luaL_typename" ref="a2bee94954917c5bccb05d6578f3c675b" args="(L, i)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define luaL_typename</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">L, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">i&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;lua_typename(L, lua_type(L,(i)))</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>luaL_typename</p>
<p>[-0, +0, -]</p>
<p>const char *luaL_typename (lua_State *L, int index);</p>
<p>Returns the name of the type of the value at the given index.</p>
<p>返回给定索引处的值的类型名。 </p>

</div>
</div>
<hr/><h2>Typedef Documentation</h2>
<a class="anchor" id="a5f2195b3845806aa4bd9117b11b4d91c"></a><!-- doxytag: member="lauxlib.h::luaL_Buffer" ref="a5f2195b3845806aa4bd9117b11b4d91c" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="structlua_l___buffer.html">luaL_Buffer</a>  <a class="el" href="structlua_l___buffer.html">luaL_Buffer</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p><a class="el" href="structlua_l___buffer.html">luaL_Buffer</a></p>
<p>typedef struct <a class="el" href="structlua_l___buffer.html">luaL_Buffer</a> <a class="el" href="structlua_l___buffer.html">luaL_Buffer</a>;</p>
<p>Type for a string buffer.</p>
<p>A string buffer allows C code to build Lua strings piecemeal. Its pattern of use is as follows:</p>
<p>First you declare a variable b of type <a class="el" href="structlua_l___buffer.html">luaL_Buffer</a>.</p>
<p>Then you initialize it with a call luaL_buffinit(L, &amp;b).</p>
<p>Then you add string pieces to the buffer calling any of the luaL_add* functions.</p>
<p>You finish by calling luaL_pushresult(&amp;b). This call leaves the final string on the top of the stack.</p>
<p>During its normal operation, a string buffer uses a variable number of stack slots. So, while using a buffer, you cannot assume that you know where the top of the stack is. You can use the stack between successive calls to buffer operations as long as that use is balanced; that is, when you call a buffer operation, the stack is at the same level it was immediately after the previous buffer operation. (The only exception to this rule is luaL_addvalue.) After calling luaL_pushresult the stack is back to its level when the buffer was initialized, plus the final string on its top.</p>
<p>字符串缓冲器类型。</p>
<p>字符串缓冲器允许C代码逐段地构建Lua字符串。其使用模式如下：</p>
<p>首先声明luaL_Buffer类型的变量b。</p>
<p>接着调用luaL_buffinit(L, &amp;b)初始化它。</p>
<p>然后调用luaL_add*函数把字符串片断添加到缓冲器。</p>
<p>通过调用luaL_pushresult(&amp;b)结束。该调用把最终的字符串放在栈顶。</p>
<p>在字符串缓冲器的常规操作期间，它占用的栈槽数量不固定。所以，使用缓冲器时，你不能假定知道栈顶在哪儿。只要用法是对称的，你就能在连续的对缓冲器操作的调用之间使用栈；就是说，当你调用缓冲器操作时，栈处于前一个缓冲器操作后立刻得到的水平。（该规则的唯一例外是luaL_addvalue。）调用luaL_pushresult之后，栈回到缓冲器被初始化时的水平，加上栈顶的最终字符串。 </p>

</div>
</div>
<a class="anchor" id="a48bebf7b56d108021c1ae29549c912f9"></a><!-- doxytag: member="lauxlib.h::luaL_Reg" ref="a48bebf7b56d108021c1ae29549c912f9" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="structlua_l___reg.html">luaL_Reg</a>  <a class="el" href="structlua_l___reg.html">luaL_Reg</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p><a class="el" href="structlua_l___reg.html">luaL_Reg</a></p>
<p>typedef struct <a class="el" href="structlua_l___reg.html">luaL_Reg</a> {</p>
<p>const char *name;</p>
<p>lua_CFunction func;</p>
<p>} <a class="el" href="structlua_l___reg.html">luaL_Reg</a>;</p>
<p>Type for arrays of functions to be registered by luaL_register. name is the function name and func is a pointer to the function. Any array of <a class="el" href="structlua_l___reg.html">luaL_Reg</a> must end with an sentinel entry in which both name and func are NULL.</p>
<p>用于要被luaL_register注册的函数数组的类型。name是函数名，func是函数指针。任何luaL_Reg数组必须以name和func都为NULL的标记项结尾。 </p>

</div>
</div>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="ae352d571a7b93c6b311b7aa993f9aaba"></a><!-- doxytag: member="lauxlib.h::luaI_openlib" ref="ae352d571a7b93c6b311b7aa993f9aaba" args="(lua_State *L, const char *libname, const luaL_Reg *l, int nup)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LUALIB_API void() luaI_openlib </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="lua_8h.html#a28186297f2e9f2de0652504633de8fb3">lua_State</a> *&#160;</td>
          <td class="paramname"> <em>L</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"> <em>libname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structlua_l___reg.html">luaL_Reg</a> *&#160;</td>
          <td class="paramname"> <em>l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"> <em>nup</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a06fceedb3abb1272566ca22c96e34b95"></a><!-- doxytag: member="lauxlib.h::luaL_addlstring" ref="a06fceedb3abb1272566ca22c96e34b95" args="(luaL_Buffer *B, const char *s, size_t l)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LUALIB_API void() luaL_addlstring </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structlua_l___buffer.html">luaL_Buffer</a> *&#160;</td>
          <td class="paramname"> <em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"> <em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"> <em>l</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>luaL_addlstring</p>
<p>[-0, +0, m]</p>
<p>void luaL_addlstring (<a class="el" href="structlua_l___buffer.html">luaL_Buffer</a> *B, const char *s, size_t l);</p>
<p>Adds the string pointed to by s with length l to the buffer B (see <a class="el" href="structlua_l___buffer.html">luaL_Buffer</a>). The string may contain embedded zeros.</p>
<p>把指向s的长度l的字符串加入缓冲区B（参考luaL_Buffer）。</p>
<p>这个字符串可以包含嵌入的0。 </p>

</div>
</div>
<a class="anchor" id="ad9c038f6e108e216011aca1801f84f44"></a><!-- doxytag: member="lauxlib.h::luaL_addstring" ref="ad9c038f6e108e216011aca1801f84f44" args="(luaL_Buffer *B, const char *s)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LUALIB_API void() luaL_addstring </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structlua_l___buffer.html">luaL_Buffer</a> *&#160;</td>
          <td class="paramname"> <em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"> <em>s</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>luaL_addstring</p>
<p>[-0, +0, m]</p>
<p>void luaL_addstring (<a class="el" href="structlua_l___buffer.html">luaL_Buffer</a> *B, const char *s);</p>
<p>Adds the zero-terminated string pointed to by s to the buffer B (see <a class="el" href="structlua_l___buffer.html">luaL_Buffer</a>). The string may not contain embedded zeros.</p>
<p>把s指向的0结尾的字符串添加到缓冲器B（见luaL_Buffer）。字符串不可包含内嵌的0。 </p>

</div>
</div>
<a class="anchor" id="aeeb03d69681da0ec0e952b582ce3841c"></a><!-- doxytag: member="lauxlib.h::luaL_addvalue" ref="aeeb03d69681da0ec0e952b582ce3841c" args="(luaL_Buffer *B)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LUALIB_API void() luaL_addvalue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structlua_l___buffer.html">luaL_Buffer</a> *&#160;</td>
          <td class="paramname"> <em>B</em>&#160;)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>luaL_addvalue</p>
<p>[-1, +0, m]</p>
<p>void luaL_addvalue (<a class="el" href="structlua_l___buffer.html">luaL_Buffer</a> *B);</p>
<p>Adds the value at the top of the stack to the buffer B (see <a class="el" href="structlua_l___buffer.html">luaL_Buffer</a>). Pops the value.</p>
<p>This is the only function on string buffers that can (and must) be called with an extra element on the stack, which is the value to be added to the buffer.</p>
<p>把栈顶的值添加到缓冲器B（见luaL_Buffer）。弹出该值。</p>
<p>这是仅有能（且必须）用栈上的一个额外元素调用的关于字符串缓冲器的函数，该元素是要被添加到缓冲器的值。 </p>

</div>
</div>
<a class="anchor" id="a526c220d17273c63ce9973bcde4a2c4a"></a><!-- doxytag: member="lauxlib.h::luaL_argerror" ref="a526c220d17273c63ce9973bcde4a2c4a" args="(lua_State *L, int numarg, const char *extramsg)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LUALIB_API int() luaL_argerror </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="lua_8h.html#a28186297f2e9f2de0652504633de8fb3">lua_State</a> *&#160;</td>
          <td class="paramname"> <em>L</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"> <em>numarg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"> <em>extramsg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>luaL_argerror</p>
<p>[-0, +0, v]</p>
<p>int luaL_argerror (lua_State *L, int narg, const char *extramsg);</p>
<p>Raises an error with the following message, where func is retrieved from the call stack:</p>
<p>bad argument #&lt;narg&gt; to &lt;func&gt; (&lt;extramsg&gt;)</p>
<p>This function never returns, but it is an idiom to use it in C functions as return luaL_argerror(args).</p>
<p>抛出带下面的消息的错误，其中func是取自调用栈：</p>
<p>bad argument #&lt;narg&gt; to &lt;func&gt; (&lt;extramsg&gt;)</p>
<p>本函数决不返回，但是像return luaL_argerror(args)这样是用在C函数中的习惯用法。 </p>

</div>
</div>
<a class="anchor" id="aab6af54c782855fee2bef84eb41bdc00"></a><!-- doxytag: member="lauxlib.h::luaL_buffinit" ref="aab6af54c782855fee2bef84eb41bdc00" args="(lua_State *L, luaL_Buffer *B)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LUALIB_API void() luaL_buffinit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="lua_8h.html#a28186297f2e9f2de0652504633de8fb3">lua_State</a> *&#160;</td>
          <td class="paramname"> <em>L</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structlua_l___buffer.html">luaL_Buffer</a> *&#160;</td>
          <td class="paramname"> <em>B</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>luaL_buffinit</p>
<p>[-0, +0, -]</p>
<p>void luaL_buffinit (lua_State *L, <a class="el" href="structlua_l___buffer.html">luaL_Buffer</a> *B);</p>
<p>Initializes a buffer B. This function does not allocate any space; the buffer must be declared as a variable (see <a class="el" href="structlua_l___buffer.html">luaL_Buffer</a>).</p>
<p>初始化缓冲器B。本函数不分配任何空间；缓冲器必须已被声明为变量（见luaL_Buffer）。 </p>

</div>
</div>
<a class="anchor" id="af26aec8cce4a3f4448c60f402d78f17d"></a><!-- doxytag: member="lauxlib.h::luaL_callmeta" ref="af26aec8cce4a3f4448c60f402d78f17d" args="(lua_State *L, int obj, const char *e)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LUALIB_API int() luaL_callmeta </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="lua_8h.html#a28186297f2e9f2de0652504633de8fb3">lua_State</a> *&#160;</td>
          <td class="paramname"> <em>L</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"> <em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"> <em>e</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>luaL_callmeta</p>
<p>[-0, +(0|1), e]</p>
<p>int luaL_callmeta (lua_State *L, int obj, const char *e);</p>
<p>Calls a metamethod.</p>
<p>If the object at index obj has a metatable and this metatable has a field e, this function calls this field and passes the object as its only argument. In this case this function returns 1 and pushes onto the stack the value returned by the call. If there is no metatable or no metamethod, this function returns 0 (without pushing any value on the stack).</p>
<p>调用一个元方法。</p>
<p>如果索引obj处的对象具有元表且该元表具有字段e，本函数调用该字段并传入该对象为其唯一参数。这种情况下，本函数返回1并将该调用返回的值压栈。如果没有元表或没有元方法，本函数返回0（不将任何值压栈）。 </p>

</div>
</div>
<a class="anchor" id="ad78c85dce421e9cb793e205b9e81c640"></a><!-- doxytag: member="lauxlib.h::luaL_checkany" ref="ad78c85dce421e9cb793e205b9e81c640" args="(lua_State *L, int narg)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LUALIB_API void() luaL_checkany </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="lua_8h.html#a28186297f2e9f2de0652504633de8fb3">lua_State</a> *&#160;</td>
          <td class="paramname"> <em>L</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"> <em>narg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>luaL_checkany</p>
<p>[-0, +0, v]</p>
<p>void luaL_checkany (lua_State *L, int narg);</p>
<p>Checks whether the function has an argument of any type (including nil) at position narg.</p>
<p>检查函数是否在位置narg处有个任意类型（包括nil）的参数。 </p>

</div>
</div>
<a class="anchor" id="ab9c2bb4294fb7a81d3745dad5711cd63"></a><!-- doxytag: member="lauxlib.h::luaL_checkinteger" ref="ab9c2bb4294fb7a81d3745dad5711cd63" args="(lua_State *L, int numArg)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LUALIB_API <a class="el" href="lua_8h.html#a362144baa0cfb14dc38fd21438053d73">lua_Integer</a>() luaL_checkinteger </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="lua_8h.html#a28186297f2e9f2de0652504633de8fb3">lua_State</a> *&#160;</td>
          <td class="paramname"> <em>L</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"> <em>numArg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>luaL_checkinteger</p>
<p>[-0, +0, v]</p>
<p>lua_Integer luaL_checkinteger (lua_State *L, int narg);</p>
<p>Checks whether the function argument narg is a number and returns this number cast to a lua_Integer.</p>
<p>检查函数参数narg是否是一个数，并且把这个数转换为lua_Integer然后返回。 </p>

</div>
</div>
<a class="anchor" id="af4af154dcb41f8990a572e6a00c349fc"></a><!-- doxytag: member="lauxlib.h::luaL_checklstring" ref="af4af154dcb41f8990a572e6a00c349fc" args="(lua_State *L, int numArg, size_t *l)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LUALIB_API const char*() luaL_checklstring </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="lua_8h.html#a28186297f2e9f2de0652504633de8fb3">lua_State</a> *&#160;</td>
          <td class="paramname"> <em>L</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"> <em>numArg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"> <em>l</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>luaL_checklstring</p>
<p>[-0, +0, v]</p>
<p>const char *luaL_checklstring (lua_State *L, int narg, size_t *l);</p>
<p>Checks whether the function argument narg is a string and returns this string; if l is not NULL fills *l with the string's length.</p>
<p>This function uses lua_tolstring to get its result, so all conversions and caveats of that function apply here.</p>
<p>检查函数参数narg是否是一个字符串，然后返回这个字符串；如果l不是NULL则填充*l为字符串的长度。</p>
<p>这个函数使用lua_tolstring获得结果，所以那个函数的所有转换和注意事项都适用于此。 </p>

</div>
</div>
<a class="anchor" id="a3e39a4d35c3ce1555126e372a8a329c3"></a><!-- doxytag: member="lauxlib.h::luaL_checknumber" ref="a3e39a4d35c3ce1555126e372a8a329c3" args="(lua_State *L, int numArg)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LUALIB_API <a class="el" href="lua_8h.html#af0a6ed3b852d680769cfc410a0672172">lua_Number</a>() luaL_checknumber </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="lua_8h.html#a28186297f2e9f2de0652504633de8fb3">lua_State</a> *&#160;</td>
          <td class="paramname"> <em>L</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"> <em>numArg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>luaL_checknumber</p>
<p>[-0, +0, v]</p>
<p>lua_Number luaL_checknumber (lua_State *L, int narg);</p>
<p>Checks whether the function argument narg is a number and returns this number.</p>
<p>检查函数参数narg是否是一个数，并且返回这个数。 </p>

</div>
</div>
<a class="anchor" id="a638633914d3a19650db8320c1fccf161"></a><!-- doxytag: member="lauxlib.h::luaL_checkoption" ref="a638633914d3a19650db8320c1fccf161" args="(lua_State *L, int narg, const char *def, const char *const lst[])" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LUALIB_API int() luaL_checkoption </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="lua_8h.html#a28186297f2e9f2de0652504633de8fb3">lua_State</a> *&#160;</td>
          <td class="paramname"> <em>L</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"> <em>narg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"> <em>def</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *const &#160;</td>
          <td class="paramname"> <em>lst</em>[]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>luaL_checkoption</p>
<p>[-0, +0, v]</p>
<p>int luaL_checkoption (lua_State *L, int narg, const char *def, const char *const lst[]);</p>
<p>Checks whether the function argument narg is a string and searches for this string in the array lst (which must be NULL-terminated). Returns the index in the array where the string was found. Raises an error if the argument is not a string or if the string cannot be found.</p>
<p>If def is not NULL, the function uses def as a default value when there is no argument narg or if this argument is nil.</p>
<p>This is a useful function for mapping strings to C enums. (The usual convention in Lua libraries is to use strings instead of numbers to select options.)</p>
<p>检查函数参数narg是否是一个字符串并且在数组lst中搜索这个字符串（必须是NULL结束）。</p>
<p>返回数组中所找到字符串的索引。</p>
<p>如果参数不是一个字符串或字符串找不到则引发错误。</p>
<p>如果def不是NULL，当没有narg参数或者这个参数为空时，这个函数使用def作为默认值</p>
<p>这个函数对匹配字符串为C枚举值时很有用。</p>
<p>（在Lua库中普遍的约定是使用字符串代替数字去选择选项） </p>

</div>
</div>
<a class="anchor" id="a724f5a5aeee97c0b40948c8bca91341c"></a><!-- doxytag: member="lauxlib.h::luaL_checkstack" ref="a724f5a5aeee97c0b40948c8bca91341c" args="(lua_State *L, int sz, const char *msg)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LUALIB_API void() luaL_checkstack </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="lua_8h.html#a28186297f2e9f2de0652504633de8fb3">lua_State</a> *&#160;</td>
          <td class="paramname"> <em>L</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"> <em>sz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"> <em>msg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>luaL_checkstack</p>
<p>[-0, +0, v]</p>
<p>void luaL_checkstack (lua_State *L, int sz, const char *msg);</p>
<p>Grows the stack size to top + sz elements, raising an error if the stack cannot grow to that size. msg is an additional text to go into the error message.</p>
<p>增长栈尺寸到top + sz个元素，如果不能增长到那个尺寸则引发错误。msg是加入错误消息的补充文本。 </p>

</div>
</div>
<a class="anchor" id="ae5f465fb757069d016a10b106c69bdd7"></a><!-- doxytag: member="lauxlib.h::luaL_checktype" ref="ae5f465fb757069d016a10b106c69bdd7" args="(lua_State *L, int narg, int t)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LUALIB_API void() luaL_checktype </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="lua_8h.html#a28186297f2e9f2de0652504633de8fb3">lua_State</a> *&#160;</td>
          <td class="paramname"> <em>L</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"> <em>narg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"> <em>t</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>luaL_checktype</p>
<p>[-0, +0, v]</p>
<p>void luaL_checktype (lua_State *L, int narg, int t);</p>
<p>Checks whether the function argument narg has type t. See lua_type for the encoding of types for t.</p>
<p>检查函数参数narg是否拥有类型t。</p>
<p>参考lua_type获得t的类型编码。 </p>

</div>
</div>
<a class="anchor" id="aed8d8e4f3b95c6bcac246ec9895027b1"></a><!-- doxytag: member="lauxlib.h::luaL_checkudata" ref="aed8d8e4f3b95c6bcac246ec9895027b1" args="(lua_State *L, int ud, const char *tname)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LUALIB_API void*() luaL_checkudata </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="lua_8h.html#a28186297f2e9f2de0652504633de8fb3">lua_State</a> *&#160;</td>
          <td class="paramname"> <em>L</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"> <em>ud</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"> <em>tname</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>luaL_checkudata</p>
<p>[-0, +0, v]</p>
<p>void *luaL_checkudata (lua_State *L, int narg, const char *tname);</p>
<p>Checks whether the function argument narg is a userdata of the type tname (see luaL_newmetatable).</p>
<p>检查函数参数narg是否是类型tname的用户定义类型（参考luaL_newmetatable） </p>

</div>
</div>
<a class="anchor" id="a994f73d7985c30672469a260d9e86ae6"></a><!-- doxytag: member="lauxlib.h::luaL_error" ref="a994f73d7985c30672469a260d9e86ae6" args="(lua_State *L, const char *fmt,...)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LUALIB_API int() luaL_error </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="lua_8h.html#a28186297f2e9f2de0652504633de8fb3">lua_State</a> *&#160;</td>
          <td class="paramname"> <em>L</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"> <em>fmt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"> <em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>luaL_error</p>
<p>[-0, +0, v]</p>
<p>int luaL_error (lua_State *L, const char *fmt, ...);</p>
<p>Raises an error. The error message format is given by fmt plus any extra arguments, following the same rules of lua_pushfstring. It also adds at the beginning of the message the file name and the line number where the error occurred, if this information is available.</p>
<p>This function never returns, but it is an idiom to use it in C functions as return luaL_error(args).</p>
<p>引发错误。</p>
<p>错误信息的格式由fmt指定，外加额外的参数，遵循与lua_pushfstring相同的规则。</p>
<p>它还会在信息的开头加上文件名和发生错误的行号，如果这类信息可用的话。</p>
<p>这个函数从不返回，但习惯在C函数内以return luaL_error(args)方式使用。 </p>

</div>
</div>
<a class="anchor" id="a561116e7d323baa7ae514054bc15978f"></a><!-- doxytag: member="lauxlib.h::luaL_findtable" ref="a561116e7d323baa7ae514054bc15978f" args="(lua_State *L, int idx, const char *fname, int szhint)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LUALIB_API const char*() luaL_findtable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="lua_8h.html#a28186297f2e9f2de0652504633de8fb3">lua_State</a> *&#160;</td>
          <td class="paramname"> <em>L</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"> <em>idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"> <em>fname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"> <em>szhint</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="aed3f129411ba1ec14f813d650f16384d"></a><!-- doxytag: member="lauxlib.h::luaL_getmetafield" ref="aed3f129411ba1ec14f813d650f16384d" args="(lua_State *L, int obj, const char *e)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LUALIB_API int() luaL_getmetafield </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="lua_8h.html#a28186297f2e9f2de0652504633de8fb3">lua_State</a> *&#160;</td>
          <td class="paramname"> <em>L</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"> <em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"> <em>e</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>luaL_getmetafield</p>
<p>[-0, +(0|1), m]</p>
<p>int luaL_getmetafield (lua_State *L, int obj, const char *e);</p>
<p>Pushes onto the stack the field e from the metatable of the object at index obj. If the object does not have a metatable, or if the metatable does not have this field, returns 0 and pushes nothing.</p>
<p>把来自索引obj处的对象的元表的字段e压栈。如果对象没有元表或其元表没有该字段，则返回0且不会压栈任何东西。 </p>

</div>
</div>
<a class="anchor" id="a46672be75da57e1a464c5c6d80f19064"></a><!-- doxytag: member="lauxlib.h::luaL_gsub" ref="a46672be75da57e1a464c5c6d80f19064" args="(lua_State *L, const char *s, const char *p, const char *r)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LUALIB_API const char*() luaL_gsub </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="lua_8h.html#a28186297f2e9f2de0652504633de8fb3">lua_State</a> *&#160;</td>
          <td class="paramname"> <em>L</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"> <em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"> <em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"> <em>r</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>luaL_gsub</p>
<p>[-0, +1, m]</p>
<p>const char *luaL_gsub (lua_State *L, const char *s, const char *p, const char *r);</p>
<p>Creates a copy of string s by replacing any occurrence of the string p with the string r. Pushes the resulting string on the stack and returns it.</p>
<p>通过把出现的任何字符串p替换为字符串r来创建字符串s的拷贝。把结果字符串压栈并返回它。 </p>

</div>
</div>
<a class="anchor" id="a74d560ea0256e7b48496a4acb1d7522e"></a><!-- doxytag: member="lauxlib.h::luaL_loadbuffer" ref="a74d560ea0256e7b48496a4acb1d7522e" args="(lua_State *L, const char *buff, size_t sz, const char *name)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LUALIB_API int() luaL_loadbuffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="lua_8h.html#a28186297f2e9f2de0652504633de8fb3">lua_State</a> *&#160;</td>
          <td class="paramname"> <em>L</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"> <em>buff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"> <em>sz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"> <em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>luaL_loadbuffer</p>
<p>[-0, +1, m]</p>
<p>int luaL_loadbuffer (lua_State *L, const char *buff, size_t sz, const char *name);</p>
<p>Loads a buffer as a Lua chunk. This function uses lua_load to load the chunk in the buffer pointed to by buff with size sz.</p>
<p>This function returns the same results as lua_load. name is the chunk name, used for debug information and error messages.</p>
<p>载入缓冲器并作为一个Lua单元。本函数用lua_load来加载缓冲器中由buff指向且长度为sz的单元。</p>
<p>本函数返回同lua_load一样的结果。name是单元名字，用于调试信息和错误消息。 </p>

</div>
</div>
<a class="anchor" id="afa862c5bdbbcfc8f46e0cac9f32a771e"></a><!-- doxytag: member="lauxlib.h::luaL_loadfile" ref="afa862c5bdbbcfc8f46e0cac9f32a771e" args="(lua_State *L, const char *filename)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LUALIB_API int() luaL_loadfile </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="lua_8h.html#a28186297f2e9f2de0652504633de8fb3">lua_State</a> *&#160;</td>
          <td class="paramname"> <em>L</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"> <em>filename</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>luaL_loadfile</p>
<p>[-0, +1, m]</p>
<p>int luaL_loadfile (lua_State *L, const char *filename);</p>
<p>Loads a file as a Lua chunk. This function uses lua_load to load the chunk in the file named filename. If filename is NULL, then it loads from the standard input. The first line in the file is ignored if it starts with a #.</p>
<p>This function returns the same results as lua_load, but it has an extra error code LUA_ERRFILE if it cannot open/read the file.</p>
<p>As lua_load, this function only loads the chunk; it does not run it.</p>
<p>载入文件作为一个Lua单元。本函数用lua_load来载入名为filename的文件中的单元。如果filename是NULL，则从标准输入载入。文件中的第一行如果以::开头则被忽略。</p>
<p>本函数返回同lua_load一样的结果，除了有个额外的错误代码LUA_ERRFILE，用于不能打开/读取文件的情况。</p>
<p>同lua_load一样，本函数只载入单元；不会运行它。 </p>

</div>
</div>
<a class="anchor" id="ac88130d6214ff6b3e2f1781f327807eb"></a><!-- doxytag: member="lauxlib.h::luaL_loadstring" ref="ac88130d6214ff6b3e2f1781f327807eb" args="(lua_State *L, const char *s)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LUALIB_API int() luaL_loadstring </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="lua_8h.html#a28186297f2e9f2de0652504633de8fb3">lua_State</a> *&#160;</td>
          <td class="paramname"> <em>L</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"> <em>s</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>luaL_loadstring</p>
<p>[-0, +1, m]</p>
<p>int luaL_loadstring (lua_State *L, const char *s);</p>
<p>Loads a string as a Lua chunk. This function uses lua_load to load the chunk in the zero-terminated string s.</p>
<p>This function returns the same results as lua_load.</p>
<p>Also as lua_load, this function only loads the chunk; it does not run it.</p>
<p>载入字符串作为一个Lua单元。本函数用lua_load来载入以0结尾的字符串s中的单元。</p>
<p>本函数返回同lua_load一样的结果。</p>
<p>本函数只载入单元，这也同lua_load一样；不会运行它。 </p>

</div>
</div>
<a class="anchor" id="a0e9e032108e7aedc05836b0c1d72a0fa"></a><!-- doxytag: member="lauxlib.h::luaL_newmetatable" ref="a0e9e032108e7aedc05836b0c1d72a0fa" args="(lua_State *L, const char *tname)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LUALIB_API int() luaL_newmetatable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="lua_8h.html#a28186297f2e9f2de0652504633de8fb3">lua_State</a> *&#160;</td>
          <td class="paramname"> <em>L</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"> <em>tname</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>luaL_newmetatable</p>
<p>[-0, +1, m]</p>
<p>int luaL_newmetatable (lua_State *L, const char *tname);</p>
<p>If the registry already has the key tname, returns 0. Otherwise, creates a new table to be used as a metatable for userdata, adds it to the registry with key tname, and returns 1.</p>
<p>In both cases pushes onto the stack the final value associated with tname in the registry.</p>
<p>如果注册表已经有了键tname则返回0。否则，创建将用作用户数据的元表的新表，把它同键tname一起加入注册表，并且返回1。</p>
<p>两种情况都把注册表中与tname相关联的最终值压栈。 </p>

</div>
</div>
<a class="anchor" id="a7d8712fcede90ae93d5a9a7b409c586e"></a><!-- doxytag: member="lauxlib.h::luaL_newstate" ref="a7d8712fcede90ae93d5a9a7b409c586e" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LUALIB_API <a class="el" href="lua_8h.html#a28186297f2e9f2de0652504633de8fb3">lua_State</a>*() luaL_newstate </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname">&#160;)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>luaL_newstate</p>
<p>[-0, +0, -]</p>
<p>lua_State *luaL_newstate (void);</p>
<p>Creates a new Lua state. It calls lua_newstate with an allocator based on the standard C realloc function and then sets a panic function (see lua_atpanic) that prints an error message to the standard error output in case of fatal errors.</p>
<p>Returns the new state, or NULL if there is a memory allocation error.</p>
<p>创建新的Lua状态机。它用基于标准C的realloc函数的分配器调用lua_newstate，然后设置一个在发生重大错误时向标准错误输出打印一条错误消息的应急函数（见lua_atpanic）。</p>
<p>返回新的状态机，如果发生内存分配错误则返回NULL。 </p>

</div>
</div>
<a class="anchor" id="a2b17cdda9e7ed73a1cd152cd386dc7a4"></a><!-- doxytag: member="lauxlib.h::luaL_optinteger" ref="a2b17cdda9e7ed73a1cd152cd386dc7a4" args="(lua_State *L, int nArg, lua_Integer def)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LUALIB_API <a class="el" href="lua_8h.html#a362144baa0cfb14dc38fd21438053d73">lua_Integer</a>() luaL_optinteger </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="lua_8h.html#a28186297f2e9f2de0652504633de8fb3">lua_State</a> *&#160;</td>
          <td class="paramname"> <em>L</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"> <em>nArg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="lua_8h.html#a362144baa0cfb14dc38fd21438053d73">lua_Integer</a>&#160;</td>
          <td class="paramname"> <em>def</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>luaL_optinteger</p>
<p>[-0, +0, v]</p>
<p>lua_Integer luaL_optinteger (lua_State *L, int narg, lua_Integer d);</p>
<p>If the function argument narg is a number, returns this number cast to a lua_Integer. If this argument is absent or is nil, returns d. Otherwise, raises an error.</p>
<p>如果函数参数narg是数字，则把该数字转型为lua_Integer返回。如果该参数不存在或为nil则返回d。否则引发错误。 </p>

</div>
</div>
<a class="anchor" id="a15b8c426b2e1b0cd1f9ddc32bc94df2f"></a><!-- doxytag: member="lauxlib.h::luaL_optlstring" ref="a15b8c426b2e1b0cd1f9ddc32bc94df2f" args="(lua_State *L, int numArg, const char *def, size_t *l)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LUALIB_API const char*() luaL_optlstring </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="lua_8h.html#a28186297f2e9f2de0652504633de8fb3">lua_State</a> *&#160;</td>
          <td class="paramname"> <em>L</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"> <em>numArg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"> <em>def</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"> <em>l</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>luaL_optlstring</p>
<p>[-0, +0, v]</p>
<p>const char *luaL_optlstring (lua_State *L, int narg, const char *d, size_t *l);</p>
<p>If the function argument narg is a string, returns this string. If this argument is absent or is nil, returns d. Otherwise, raises an error.</p>
<p>If l is not NULL, fills the position *l with the results's length.</p>
<p>如果函数参数narg是字符串则返回它。如果该参数不存在或为nil则返回d。否则引发错误。</p>
<p>如果l不为NULL，则用结果的长度填充位置*l。 </p>

</div>
</div>
<a class="anchor" id="a001e2679c64c24eefbaf478fd0c22f97"></a><!-- doxytag: member="lauxlib.h::luaL_optnumber" ref="a001e2679c64c24eefbaf478fd0c22f97" args="(lua_State *L, int nArg, lua_Number def)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LUALIB_API <a class="el" href="lua_8h.html#af0a6ed3b852d680769cfc410a0672172">lua_Number</a>() luaL_optnumber </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="lua_8h.html#a28186297f2e9f2de0652504633de8fb3">lua_State</a> *&#160;</td>
          <td class="paramname"> <em>L</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"> <em>nArg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="lua_8h.html#af0a6ed3b852d680769cfc410a0672172">lua_Number</a>&#160;</td>
          <td class="paramname"> <em>def</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>luaL_optnumber</p>
<p>[-0, +0, v]</p>
<p>lua_Number luaL_optnumber (lua_State *L, int narg, lua_Number d);</p>
<p>If the function argument narg is a number, returns this number. If this argument is absent or is nil, returns d. Otherwise, raises an error.</p>
<p>如果函数参数narg是数字则返回它。如果该参数不存在或为nil则返回d。否则引发错误。 </p>

</div>
</div>
<a class="anchor" id="adb0d0b797f1b8cc8ec4cda17a2939f87"></a><!-- doxytag: member="lauxlib.h::luaL_prepbuffer" ref="adb0d0b797f1b8cc8ec4cda17a2939f87" args="(luaL_Buffer *B)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LUALIB_API char*() luaL_prepbuffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structlua_l___buffer.html">luaL_Buffer</a> *&#160;</td>
          <td class="paramname"> <em>B</em>&#160;)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>luaL_prepbuffer</p>
<p>[-0, +0, -]</p>
<p>char *luaL_prepbuffer (<a class="el" href="structlua_l___buffer.html">luaL_Buffer</a> *B);</p>
<p>Returns an address to a space of size LUAL_BUFFERSIZE where you can copy a string to be added to buffer B (see <a class="el" href="structlua_l___buffer.html">luaL_Buffer</a>). After copying the string into this space you must call luaL_addsize with the size of the string to actually add it to the buffer.</p>
<p>返回尺寸为LUAL_BUFFERSIZE的空间的地址，你能把要被加入缓冲器B的字符串拷贝到其中（见luaL_Buffer）。在把字符串拷贝到该空间中以后，你必须用字符串的尺寸调用luaL_addsize来把它加入缓冲器中。 </p>

</div>
</div>
<a class="anchor" id="aac5dfab9ba0ced4f5ae3b22aa35faffe"></a><!-- doxytag: member="lauxlib.h::luaL_pushresult" ref="aac5dfab9ba0ced4f5ae3b22aa35faffe" args="(luaL_Buffer *B)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LUALIB_API void() luaL_pushresult </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structlua_l___buffer.html">luaL_Buffer</a> *&#160;</td>
          <td class="paramname"> <em>B</em>&#160;)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>luaL_pushresult</p>
<p>[-?, +1, m]</p>
<p>void luaL_pushresult (<a class="el" href="structlua_l___buffer.html">luaL_Buffer</a> *B);</p>
<p>Finishes the use of buffer B leaving the final string on the top of the stack.</p>
<p>结束对缓冲器B的使用，把最终字符串留在栈顶。 </p>

</div>
</div>
<a class="anchor" id="a2b69e67252d95df410818251f4b2d8e5"></a><!-- doxytag: member="lauxlib.h::luaL_ref" ref="a2b69e67252d95df410818251f4b2d8e5" args="(lua_State *L, int t)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LUALIB_API int() luaL_ref </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="lua_8h.html#a28186297f2e9f2de0652504633de8fb3">lua_State</a> *&#160;</td>
          <td class="paramname"> <em>L</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"> <em>t</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>luaL_ref</p>
<p>[-1, +0, m]</p>
<p>int luaL_ref (lua_State *L, int t);</p>
<p>Creates and returns a reference, in the table at index t, for the object at the top of the stack (and pops the object).</p>
<p>A reference is a unique integer key. As long as you do not manually add integer keys into table t, luaL_ref ensures the uniqueness of the key it returns. You can retrieve an object referred by reference r by calling lua_rawgeti(L, t, r). Function luaL_unref frees a reference and its associated object.</p>
<p>If the object at the top of the stack is nil, luaL_ref returns the constant LUA_REFNIL. The constant LUA_NOREF is guaranteed to be different from any reference returned by luaL_ref.</p>
<p>在索引t处的表中为栈顶的对象创建一个引用（reference）并返回（而且弹出该对象）。</p>
<p>引用是唯一的整数键。只要你不手工向表t中加入整数键，luaL_ref保证它返回的键的唯一性。你可通过调用lua_rawgeti(L, t, r)取回被r引用的对象。函数luaL_unref释放引用及其关联的对象。</p>
<p>如果栈顶的对象是nil，luaL_ref返回常量LUA_REFNIL。常量LUA_NOREF被确保与luaL_ref返回的任何引用都不同。 </p>

</div>
</div>
<a class="anchor" id="a258c0fd40d57aec9cf62ebd74be7666e"></a><!-- doxytag: member="lauxlib.h::luaL_register" ref="a258c0fd40d57aec9cf62ebd74be7666e" args="(lua_State *L, const char *libname, const luaL_Reg *l)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LUALIB_API void() luaL_register </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="lua_8h.html#a28186297f2e9f2de0652504633de8fb3">lua_State</a> *&#160;</td>
          <td class="paramname"> <em>L</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"> <em>libname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structlua_l___reg.html">luaL_Reg</a> *&#160;</td>
          <td class="paramname"> <em>l</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>luaL_register</p>
<p>[-(0|1), +1, m]</p>
<p>void luaL_register (lua_State *L, const char *libname, const <a class="el" href="structlua_l___reg.html">luaL_Reg</a> *l);</p>
<p>Opens a library.</p>
<p>When called with libname equal to NULL, it simply registers all functions in the list l (see <a class="el" href="structlua_l___reg.html">luaL_Reg</a>) into the table on the top of the stack.</p>
<p>When called with a non-null libname, luaL_register creates a new table t, sets it as the value of the global variable libname, sets it as the value of package.loaded[libname], and registers on it all functions in the list l. If there is a table in package.loaded[libname] or in variable libname, reuses this table instead of creating a new one.</p>
<p>In any case the function leaves the table on the top of the stack.</p>
<p>打开一个库。</p>
<p>当以libname等于NULL调用时，它只是注册列表l中的所有函数（见luaL_Reg）到栈顶的表中。</p>
<p>当以非空的libname调用时，luaL_register创建新表t，把它设为全局变量libname的值，和package.loaded[libname]的值，并把列表l中的所有函数注册到该表。如果package.loaded[libname]中或变量libname中有个表，则重用该表而不是创建一个新的。</p>
<p>无论如何函数都把表留在栈顶。 </p>

</div>
</div>
<a class="anchor" id="a022056a7197e2e2c12f2b65b2993fd53"></a><!-- doxytag: member="lauxlib.h::luaL_typerror" ref="a022056a7197e2e2c12f2b65b2993fd53" args="(lua_State *L, int narg, const char *tname)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LUALIB_API int() luaL_typerror </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="lua_8h.html#a28186297f2e9f2de0652504633de8fb3">lua_State</a> *&#160;</td>
          <td class="paramname"> <em>L</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"> <em>narg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"> <em>tname</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>luaL_typerror</p>
<p>[-0, +0, v]</p>
<p>int luaL_typerror (lua_State *L, int narg, const char *tname);</p>
<p>Generates an error with a message like the following:</p>
<p>location: bad argument narg to 'func' (tname expected, got rt)</p>
<p>where location is produced by luaL_where, func is the name of the current function, and rt is the type name of the actual argument.</p>
<p>用类似下面的消息产生一个错误：</p>
<p>location: bad argument narg to 'func' (tname expected, got rt)</p>
<p>其中location由luaL_where产生，func是当前函数名，且rt是实际参数的类型名。 </p>

</div>
</div>
<a class="anchor" id="a6200030ecae784852045161274501e0e"></a><!-- doxytag: member="lauxlib.h::luaL_unref" ref="a6200030ecae784852045161274501e0e" args="(lua_State *L, int t, int ref)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LUALIB_API void() luaL_unref </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="lua_8h.html#a28186297f2e9f2de0652504633de8fb3">lua_State</a> *&#160;</td>
          <td class="paramname"> <em>L</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"> <em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"> <em>ref</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>luaL_unref</p>
<p>[-0, +0, -]</p>
<p>void luaL_unref (lua_State *L, int t, int ref);</p>
<p>Releases reference ref from the table at index t (see luaL_ref). The entry is removed from the table, so that the referred object can be collected. The reference ref is also freed to be used again.</p>
<p>If ref is LUA_NOREF or LUA_REFNIL, luaL_unref does nothing.</p>
<p>解除来自索引t处的表的引用ref（见luaL_ref）。该项从表中删除，所以被引用的对象可被回收。引用ref也被释放以备再次使用。</p>
<p>如果ref是LUA_NOREF或LUA_REFNIL，luaL_unref什么也不做。 </p>

</div>
</div>
<a class="anchor" id="a269122a77674ca63c9193c2a30b4729e"></a><!-- doxytag: member="lauxlib.h::luaL_where" ref="a269122a77674ca63c9193c2a30b4729e" args="(lua_State *L, int lvl)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LUALIB_API void() luaL_where </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="lua_8h.html#a28186297f2e9f2de0652504633de8fb3">lua_State</a> *&#160;</td>
          <td class="paramname"> <em>L</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"> <em>lvl</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>luaL_where</p>
<p>[-0, +1, m]</p>
<p>void luaL_where (lua_State *L, int lvl);</p>
<p>Pushes onto the stack a string identifying the current position of the control at level lvl in the call stack. Typically this string has the following format:</p>
<p>chunkname:currentline:</p>
<p>Level 0 is the running function, level 1 is the function that called the running function, etc.</p>
<p>This function is used to build a prefix for error messages.</p>
<p>压入一个标识当前在lvl层调用堆栈的控制位置到堆栈中。</p>
<p>特别地这个字符串格式如下：</p>
<p>块名:当前行:</p>
<p>0层是正在运行的函数，1层是调用运行中函数的函数，如此类推。</p>
<p>这个函数用于构建错误信息的前缀。 </p>

</div>
</div>
</div>
<!--- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Data Structures</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Defines</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<hr class="footer"/><address class="footer"><small>Generated on Mon Jun 6 2011 16:02:28 for lua by&#160;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.2 </small></address>
</body>
</html>
